/***************************************************************************** * Copyright (c) 1999-2002, Pierre-Olivier Latour * http://www.pol-online.net * info@pol-online.net * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA. *****************************************************************************/#include			"Print Server.h"#include			"Preferences.h"#include			"Utils.h"#include			"Window Server.h"#include			"Filter.h"#if !__DEMO__ && !__DEBUG__#include			"Serial Number.h"#endif//CONSTANTS:#define		kLastSeparatorTolerance		5#define		kPrintStringsID				133#define		kPrint_HeaderFontName		"\pArial"#define		kPrint_HeaderFontSize		12#define		kPrint_HeaderFontHeight		kPrint_HeaderFontSize#define		kPrint_HeaderHeight			(kPrint_HeaderFontSize + 4)#define		kPrint_LineFontName			appPrefs->printFontName#define		kPrint_LineFontSize			appPrefs->printFontSize#define		kPrint_LineTextOffset		4#define		kPrint_ColorLine			0xEFFF#define		kPrint_ColorSeparator		0x7FFF#define		kPrint_AreaHeaderHeight		30#define		kPrint_AreaTitleHeight		120#define		kPrint_AreaFooterHeight		50#define		kTitle_Column_1				5#define		kTitle_Column_2				125#define		kTitle_Column_3				240#define		kTitle_Column_4				110#define		kCmPerInch					2.54//ROUTINES:PrintServer::PrintServer(ErrorManagerPtr errorManager, Handle savePrintSettings, Boolean isTHPrint){	OSErr				theError;#if TARGET_API_MAC_CARBON	PMPrintSession		printSession;#endif	//Reset	active = false;	#if TARGET_API_MAC_CARBON	if(savePrintSettings && isTHPrint) {		DisposeHandle(savePrintSettings);		savePrintSettings = NULL;	}		theError = PMCreateSession(&printSession);	if(theError == noErr) {		if(savePrintSettings == NULL) {			printSettings = NULL;			theError = PMCreatePageFormat(&_pmPageFormat);			if(theError == noErr) {				theError = PMSessionDefaultPageFormat(printSession, _pmPageFormat);				if(theError == noErr)				theError = PMFlattenPageFormat(_pmPageFormat, &printSettings);			}		}		else {			printSettings = savePrintSettings;			theError = PMUnflattenPageFormat(printSettings, &_pmPageFormat);			/*if(theError == noErr)			theError = PMValidatePageFormat(_pmPageFormat, kPMDontWantBoolean);*/		}			PMRelease(&printSession);	}#else	if(savePrintSettings && (!isTHPrint || (GetHandleSize(savePrintSettings) != sizeof(TPrint)))) {		DisposeHandle(savePrintSettings);		savePrintSettings = NULL;	}		if(savePrintSettings == NULL) {		printSettings = NewHandle(sizeof(TPrint));		if(printSettings != NULL) {			PrOpen();			theError = PrError();			if(theError == noErr) {				PrintDefault((THPrint) printSettings);				theError = PrError();				PrClose();			}		}		else		theError = MemError();	}	else {		printSettings = savePrintSettings;		PrOpen();		theError = PrError();		if(theError == noErr) {			PrValidate((THPrint) printSettings);			theError = PrError();			PrClose();		}	}#endif		//Activate printing	if(theError) {		if(printSettings)		DisposeHandle(printSettings);		printSettings = NULL;	}	else	active = true;}PrintServer::~PrintServer(){	if(printSettings)	DisposeHandle(printSettings);#if TARGET_API_MAC_CARBON	if(_pmPageFormat)	PMRelease(&_pmPageFormat);#endif}long PrintServer::_CountPages(Rect* pageRect, OperationPtr operation){	short				lineHeight = _lineFontInfo.ascent + _lineFontInfo.descent + _lineFontInfo.leading;	long				count = 1;	short				position;		if(operation == NULL)	return 0;		while(1) {		position = pageRect->top + kPrint_AreaHeaderHeight + lineHeight + 1;		if(count == 1)		position += kPrint_AreaTitleHeight;		while(position + lineHeight < pageRect->bottom - kPrint_AreaFooterHeight) {			position += lineHeight;			operation = operation->next;			if(operation == NULL)			return count;		}		++count;	}}Boolean PrintServer::_DrawPage(long pageNum, long pageCount, Rect* pageRect, OperationPtr operationList){	PaymentTypePtr		paymentList = appPrefs->payments->list;	CategoryPtr			categoryList = appPrefs->categories->list;	ColumnInfoPtr		column = appPrefs->operationsColumns;	short				pageWidth = pageRect->right - pageRect->left,						pageHeight = pageRect->bottom - pageRect->top;	short				lineHeight = _lineFontInfo.ascent + _lineFontInfo.descent + _lineFontInfo.leading;	RGBColor			lineColor = {kPrint_ColorLine,kPrint_ColorLine,kPrint_ColorLine},						separatorColor = {kPrint_ColorSeparator,kPrint_ColorSeparator,kPrint_ColorSeparator};	Boolean				sameCurrency = true;	Amount				positive = 0,						negative = 0;	long				count,						index,						i;	short				headerFontNum,						lineFontNum;	Str255				text;	Str31				temp;	unsigned long		date;	short				hPos,						vPos,						position;	RgnHandle			saveClip;	OperationPtr		operation;	Rect				theRect;		//Compute page 1 info	if(pageNum == 1) {		//Make sure all operations are in the same currency - Count & sum operations		operation = operationList;		count = 0;		do {			if((operationList->owner != operation->owner) && !FastEqualString(operationList->owner->data->currencySymbol, operation->owner->data->currencySymbol, false))			sameCurrency = false;						if(operation->flags & kOperationFlag_Expense)			negative += operation->amount;			else			positive += operation->amount;						++count;			operation = operation->next;		} while(operation);	}		//Find first operation according to page num	operation = operationList;	index = 1;	while(index != pageNum) {		vPos = pageRect->top + kPrint_AreaHeaderHeight + lineHeight + 1;		if(index == 1)		vPos += kPrint_AreaTitleHeight;		while(vPos + lineHeight <= pageRect->bottom - kPrint_AreaFooterHeight) {			vPos += lineHeight;			operation = operation->next;			if(operation == NULL)			return false;		}		++index;	}	operationList = operation;		//Get font nums	GetFNum(kPrint_HeaderFontName, &headerFontNum);	GetFNum(kPrint_LineFontName, &lineFontNum);		//Set colors	ForeColor(blackColor);	BackColor(whiteColor);		//Set page origin & clipping	SetOrigin(-pageRect->left, -pageRect->top);	saveClip = NewRgn();	if(saveClip == NULL)	return false;	GetClip(saveClip);	theRect.left = 0;	theRect.right = pageWidth;	theRect.top = 0;	theRect.bottom = pageHeight;	ClipRect(&theRect);		//Draw page header	TextFont(headerFontNum);	TextSize(kPrint_HeaderFontSize);	TextFace(italic);	MoveTo(0, kPrint_HeaderFontHeight);	XGetIndString(text, kPrintStringsID, 1);	DrawString(text);	GetDateTime(&date);	IUDateString(date, longDate, text);	MoveTo(pageWidth - StringWidth(text), kPrint_HeaderFontHeight);	DrawString(text);	TextFace(0);		//Draw title	if(pageNum == 1) {		index = application->windowServer->GetTargetNum();		if(TargetNumIsFilter(index)) {			index = TargetNumToFilterNum(index);						//C1 L1: filter name			XGetIndString(text, kPrintStringsID, 10);			MoveTo(kTitle_Column_1, kPrint_AreaHeaderHeight + kPrint_HeaderFontHeight);			DrawString(text);			MoveTo(kTitle_Column_2, kPrint_AreaHeaderHeight + kPrint_HeaderFontHeight);			DrawString(application->filterList[index]->data->name);						//C1 L2: filter description			XGetIndString(text, kPrintStringsID, 11);			MoveTo(kTitle_Column_1, kPrint_AreaHeaderHeight + kPrint_HeaderHeight + kPrint_HeaderFontHeight);			DrawString(text);			MoveTo(kTitle_Column_2, kPrint_AreaHeaderHeight + kPrint_HeaderHeight + kPrint_HeaderFontHeight);			BlockMove(application->filterList[index]->data->note, text, sizeof(Str255));			TroncateText(text, kTitle_Column_3 - kTitle_Column_2 - 2 * kPrint_LineTextOffset);			DrawString(text);						//C2 L3: currency			XGetIndString(text, kPrintStringsID, 16);			MoveTo(kTitle_Column_1, kPrint_AreaHeaderHeight + 2 * kPrint_HeaderHeight + kPrint_HeaderFontHeight);			DrawString(text);			MoveTo(kTitle_Column_2, kPrint_AreaHeaderHeight + 2 * kPrint_HeaderHeight + kPrint_HeaderFontHeight);			if(sameCurrency)			DrawString(operationList->owner->data->currencyName);			else {				XGetIndString(text, kPrintStringsID, 15);				DrawString(text);			}		}		else if(TargetNumIsAccount(index)) {			index = TargetNumToAccountNum(index);						//C1 L1: account name			XGetIndString(text, kPrintStringsID, 4);			MoveTo(kTitle_Column_1, kPrint_AreaHeaderHeight + kPrint_HeaderFontHeight);			DrawString(text);			MoveTo(kTitle_Column_2, kPrint_AreaHeaderHeight + kPrint_HeaderFontHeight);			DrawString(application->accountList[index]->data->name);						//C2 L2: currency			XGetIndString(text, kPrintStringsID, 16);			MoveTo(kTitle_Column_1, kPrint_AreaHeaderHeight + kPrint_HeaderHeight + kPrint_HeaderFontHeight);			DrawString(text);			MoveTo(kTitle_Column_2, kPrint_AreaHeaderHeight + kPrint_HeaderHeight + kPrint_HeaderFontHeight);			if(sameCurrency)			DrawString(operationList->owner->data->currencyName);			else {				XGetIndString(text, kPrintStringsID, 15);				DrawString(text);			}						//C1 L3: account current balance			XGetIndString(text, kPrintStringsID, 8);			MoveTo(kTitle_Column_1, kPrint_AreaHeaderHeight + 2 * kPrint_HeaderHeight + kPrint_HeaderFontHeight);			DrawString(text);			MoveTo(kTitle_Column_2, kPrint_AreaHeaderHeight + 2 * kPrint_HeaderHeight + kPrint_HeaderFontHeight);			AmountToCurrencyString(application->accountList[index]->GetBalance(kBalanceType_Current), text, application->accountList[index]->data->currencySymbol, !(application->accountList[index]->data->flags & kAccountFlag_NoCents), application->accountList[index]->data->flags & kAccountFlag_SymbolLeads);			DrawString(text);						//C1 L4: account future balance			XGetIndString(text, kPrintStringsID, 9);			MoveTo(kTitle_Column_1, kPrint_AreaHeaderHeight + 3 * kPrint_HeaderHeight + kPrint_HeaderFontHeight);			DrawString(text);			MoveTo(kTitle_Column_2, kPrint_AreaHeaderHeight + 3 * kPrint_HeaderHeight + kPrint_HeaderFontHeight);			AmountToCurrencyString(application->accountList[index]->GetBalance(kBalanceType_Future), text, application->accountList[index]->data->currencySymbol, !(application->accountList[index]->data->flags & kAccountFlag_NoCents), application->accountList[index]->data->flags & kAccountFlag_SymbolLeads);			DrawString(text);						//C1 L5: account reconciled balance			XGetIndString(text, kPrintStringsID, 6);			MoveTo(kTitle_Column_1, kPrint_AreaHeaderHeight + 4 * kPrint_HeaderHeight + kPrint_HeaderFontHeight);			DrawString(text);			MoveTo(kTitle_Column_2, kPrint_AreaHeaderHeight + 4 * kPrint_HeaderHeight + kPrint_HeaderFontHeight);			AmountToCurrencyString(application->accountList[index]->GetBalance(kBalanceType_Reconciled), text, application->accountList[index]->data->currencySymbol, !(application->accountList[index]->data->flags & kAccountFlag_NoCents), application->accountList[index]->data->flags & kAccountFlag_SymbolLeads);			DrawString(text);		}				//C2 L1: transaction count		XGetIndString(text, kPrintStringsID, 7);		MoveTo(pageWidth - kTitle_Column_3, kPrint_AreaHeaderHeight + kPrint_HeaderFontHeight);		DrawString(text);		MoveTo(pageWidth - kTitle_Column_4, kPrint_AreaHeaderHeight + kPrint_HeaderFontHeight);		NumToString(count, text);		DrawString(text);				//C2 L2: positive sum		XGetIndString(text, kPrintStringsID, 12);		MoveTo(pageWidth - kTitle_Column_3, kPrint_AreaHeaderHeight + kPrint_HeaderHeight + kPrint_HeaderFontHeight);		DrawString(text);		MoveTo(pageWidth - kTitle_Column_4, kPrint_AreaHeaderHeight + kPrint_HeaderHeight + kPrint_HeaderFontHeight);		if(sameCurrency)		AmountToCurrencyString(positive, text, operationList->owner->data->currencySymbol, !(operationList->owner->data->flags & kAccountFlag_NoCents), operationList->owner->data->flags & kAccountFlag_SymbolLeads);		else		XGetIndString(text, kPrintStringsID, 15);		DrawString(text);				//C2 L3: negative sum		XGetIndString(text, kPrintStringsID, 13);		MoveTo(pageWidth - kTitle_Column_3, kPrint_AreaHeaderHeight + 2 * kPrint_HeaderHeight + kPrint_HeaderFontHeight);		DrawString(text);		MoveTo(pageWidth - kTitle_Column_4, kPrint_AreaHeaderHeight + 2 * kPrint_HeaderHeight + kPrint_HeaderFontHeight);		if(sameCurrency)		AmountToCurrencyString(negative, text, operationList->owner->data->currencySymbol, !(operationList->owner->data->flags & kAccountFlag_NoCents), operationList->owner->data->flags & kAccountFlag_SymbolLeads);		else		XGetIndString(text, kPrintStringsID, 15);		DrawString(text);				//C2 L4: sum		XGetIndString(text, kPrintStringsID, 14);		MoveTo(pageWidth - kTitle_Column_3, kPrint_AreaHeaderHeight + 3 * kPrint_HeaderHeight + kPrint_HeaderFontHeight);		DrawString(text);		MoveTo(pageWidth - kTitle_Column_4, kPrint_AreaHeaderHeight + 3 * kPrint_HeaderHeight + kPrint_HeaderFontHeight);		if(sameCurrency)		AmountToCurrencyString(positive - negative, text, operationList->owner->data->currencySymbol, !(operationList->owner->data->flags & kAccountFlag_NoCents), operationList->owner->data->flags & kAccountFlag_SymbolLeads);		else		XGetIndString(text, kPrintStringsID, 15);		DrawString(text);				theRect.top = kPrint_AreaHeaderHeight;		theRect.bottom = kPrint_AreaHeaderHeight + 5 * kPrint_HeaderHeight + 1;		FrameRect(&theRect);	}		//Draw lines	vPos = kPrint_AreaHeaderHeight + lineHeight;	if(pageNum == 1)	vPos += kPrint_AreaTitleHeight;	MoveTo(0, vPos);	LineTo(pageWidth, vPos);	++vPos;	operation = operationList;	RGBForeColor(&lineColor);	index = 0;	while(operation && (vPos + lineHeight <= pageHeight - kPrint_AreaFooterHeight)) {		//Fill line if odd		if((index + 1) % 2) {			theRect.top = vPos;			theRect.bottom = theRect.top + lineHeight;			PaintRect(&theRect);		}				//Fetch next operation		operation = operation->next;		vPos += lineHeight;		++index;	}	ForeColor(blackColor);		//Draw columns	TextFont(lineFontNum);	TextSize(kPrint_LineFontSize);	hPos = 0;	for(index = 0; index < kOperationNumColumns; ++index, ++column)	if(column->flags & kColumnFlag_Printed) {		operation = operationList;		vPos = kPrint_AreaHeaderHeight;		if(pageNum == 1)		vPos += kPrint_AreaTitleHeight;				//Draw header		XGetIndString(text, kColumnStringsID, column->id);		MoveTo(hPos + column->printWidth / 2 - TextWidth(text, 1, text[0]) / 2, vPos + _lineFontInfo.ascent);		if(column->id == appPrefs->windowSortingColumn)		TextFace(underline);		else		TextFace(0);		DrawString(text);		if((column->flags & kColumnFlag_HasSeparator) && (hPos + column->printWidth < pageWidth - kLastSeparatorTolerance)) {			MoveTo(hPos + column->printWidth, vPos);			LineTo(hPos + column->printWidth, vPos + lineHeight - 1);		}		vPos += lineHeight + 1;				//Draw items		if((column->id == kOperationColumn_Warning) || (column->id == kOperationColumn_Checked))		TextFace(bold);		else		TextFace(0);			while(operation && (vPos + lineHeight <= pageHeight - kPrint_AreaFooterHeight)) {			if((column->id != kOperationColumn_Warning) && (column->id != kOperationColumn_Checked)) {				if((appPrefs->flags & kPreferencesFlag_IncomesInBold) && !(operation->flags & kOperationFlag_Expense))				TextFace(1);				else				TextFace(0);			}					switch(column->id) {								case kOperationColumn_Checked:				if(operation->flags & kOperationFlag_Checked) {					text[0] = 1;					text[1] = 'Ã';					MoveTo(hPos + kPrint_LineTextOffset, vPos + _lineFontInfo.ascent);					DrawString(text);				}				break;								case kOperationColumn_Warning:				if(operation->flags & kOperationFlag_Warning) {					text[0] = 1;					text[1] = '!';					MoveTo(hPos + kPrint_LineTextOffset, vPos + _lineFontInfo.ascent);					DrawString(text);				}				break;								default:				switch(column->id) {										case kOperationColumn_Description:					BlockMove(operation->description, text, sizeof(Str255));					break;										case kOperationColumn_Category:					if(operation->categoryNum == kUndefinedNum)					text[0] = 0;					else					BlockMove(categoryList[operation->categoryNum].name, text, sizeof(Str63));					break;										case kOperationColumn_PaymentType:					if(operation->paymentTypeNum == kUndefinedNum)					text[0] = 0;					else					BlockMove(paymentList[operation->paymentTypeNum].name, text, sizeof(Str63));					break;									case kOperationColumn_Amount:					if(appPrefs->flags & kPreferencesFlag_DisplayCurrencySymbol)					AmountToCurrencyString(operation->absoluteAmount, text, operation->owner->data->currencySymbol, !(operation->owner->data->flags & kAccountFlag_NoCents), operation->owner->data->flags & kAccountFlag_SymbolLeads);					else					AmountToString(operation->absoluteAmount, text, 0, 0, !(operation->owner->data->flags & kAccountFlag_NoCents));					break;										case kOperationColumn_Custom:					if(operation->customData[0])					BlockMove(operation->customData, text, sizeof(Str63));					else					text[0] = 0;					break;										case kOperationColumn_Date:					if(appPrefs->flags & kPreferencesFlag_LongDates)					IUDateString(operation->date, longDate, text);					else					IUDateString(operation->date, shortDate, text);					break;										case kOperationColumn_Balance:					if(appPrefs->flags & kPreferencesFlag_DisplayCurrencySymbol)					AmountToCurrencyString(operation->balance, text, operation->owner->data->currencySymbol, !(operation->owner->data->flags & kAccountFlag_NoCents), operation->owner->data->flags & kAccountFlag_SymbolLeads);					else					AmountToString(operation->balance, text, 0, 0, !(operation->owner->data->flags & kAccountFlag_NoCents));					break;									case kOperationColumn_Note: //Replace CR with cars					text[0] = 0;					for(i = 1; i <= operation->note[0]; ++i) {						if(operation->note[i] != kReturnChar)						text[++text[0]] = operation->note[i];						else						text[++text[0]] = kNoteReturnChar;					}					break;										case kOperationColumn_Income:					if(!(operation->flags & kOperationFlag_Expense)) {						if(appPrefs->flags & kPreferencesFlag_DisplayCurrencySymbol)						AmountToCurrencyString(operation->amount, text, operation->owner->data->currencySymbol, !(operation->owner->data->flags & kAccountFlag_NoCents), operation->owner->data->flags & kAccountFlag_SymbolLeads);						else						AmountToString(operation->amount, text, 0, 0, !(operation->owner->data->flags & kAccountFlag_NoCents));					}					else					text[0] = 0;					break;										case kOperationColumn_Expense:					if(operation->flags & kOperationFlag_Expense) {						if(appPrefs->flags & kPreferencesFlag_DisplayCurrencySymbol)						AmountToCurrencyString(operation->amount, text, operation->owner->data->currencySymbol, !(operation->owner->data->flags & kAccountFlag_NoCents), operation->owner->data->flags & kAccountFlag_SymbolLeads);						else						AmountToString(operation->amount, text, 0, 0, !(operation->owner->data->flags & kAccountFlag_NoCents));					}					else					text[0] = 0;					break;										case kOperationColumn_Account:					BlockMove(operation->owner->data->name, text, sizeof(Str255));					break;										default:					text[0] = 0;					break;									}				if(text[0]) {					TroncateText(text, column->printWidth - 2 * kPrint_LineTextOffset);										if(column->textAlignement == kTextAlign_Left)					position = hPos + kPrint_LineTextOffset;					else if(column->textAlignement == kTextAlign_Middle)					position = hPos + kPrint_LineTextOffset + column->printWidth / 2 - TextWidth(text, 1, text[0]) / 2;					else if(column->textAlignement == kTextAlign_Right)					position = hPos - kPrint_LineTextOffset + column->printWidth - TextWidth(text, 1, text[0]);										MoveTo(position, vPos + _lineFontInfo.ascent);					DrawString(text);				}				break;							}						//Fetch next operation			operation = operation->next;			vPos += lineHeight;		}				//Fetch next column		hPos += column->printWidth;				//Draw column separator - if not last visible column		if((column->flags & kColumnFlag_HasSeparator) && (hPos < pageWidth - kLastSeparatorTolerance)) {			RGBForeColor(&separatorColor);			if(pageNum == 1)			MoveTo(hPos, kPrint_AreaHeaderHeight + kPrint_AreaTitleHeight + lineHeight + 1);			else			MoveTo(hPos, kPrint_AreaHeaderHeight + lineHeight + 1);			LineTo(hPos, vPos - 1);			ForeColor(blackColor);		}	}		//Draw page footer	TextFont(headerFontNum);	TextSize(kPrint_HeaderFontSize);	XGetIndString(text, kPrintStringsID, 2);	NumToString(pageNum, temp);	AppendString(text, temp);	XGetIndString(temp, kPrintStringsID, 3);	AppendString(text, temp);	NumToString(pageCount, temp);	AppendString(text, temp);	MoveTo(pageWidth / 2 - StringWidth(text) / 2, pageHeight - kPrint_HeaderFontHeight);	DrawString(text);		//Restore origin	SetOrigin(0,0);		//Restore clip	SetClip(saveClip);	DisposeRgn(saveClip);		return true;}Boolean PrintServer::_ValidateColumnSettings(short pageWidth, OperationPtr list){	PaymentTypePtr		paymentList = appPrefs->payments->list;	CategoryPtr			categoryList = appPrefs->categories->list;	ColumnInfoPtr		columnList = appPrefs->operationsColumns;	short				width,						totalWidth,						minWidth;	long				i;	GrafPtr				savePort;	Str31				text;	OperationPtr		operation;		//Save port	GetPort(&savePort);	SetPortWindowPort(application->windowServer->window);		//Get line font info	GetFNum(kPrint_LineFontName, &width);	TextFont(width);	TextSize(kPrint_LineFontSize);	if(appPrefs->flags & kPreferencesFlag_IncomesInBold)	TextFace(1);	else	TextFace(0);	GetFontInfo(&_lineFontInfo);		//Adjust column visibility & fixed width	for(i = 0; i < kOperationNumColumns; ++i) {		if(columnList[i].flags & kColumnFlag_Visible)		columnList[i].flags |= kColumnFlag_Printed;		else		columnList[i].flags &= ~kColumnFlag_Printed;				if((columnList[i].id == kOperationColumn_Balance) && TargetNumIsFilter(application->windowServer->GetTargetNum()))		columnList[i].flags &= ~kColumnFlag_Printed;		else if((columnList[i].id == kOperationColumn_Account) && TargetNumIsAccount(application->windowServer->GetTargetNum()))		columnList[i].flags &= ~kColumnFlag_Printed;	}		//Compute columns ideal width	for(i = 0; i < kOperationNumColumns; ++i)	if(columnList[i].flags & kColumnFlag_Printed) {		operation = list;				columnList[i].printWidth = 0;		switch(columnList[i].id) {					case kOperationColumn_Warning:			columnList[i].printWidth = StringWidth("\p!");			break;						case kOperationColumn_Checked:			columnList[i].printWidth = StringWidth("\pÃ");			break;						case kOperationColumn_Date:			if(appPrefs->flags & kPreferencesFlag_LongDates) {				while(operation) {					IUDateString(operation->date, longDate, text);					width = StringWidth(text);					if(width > columnList[i].printWidth)					columnList[i].printWidth = width;					operation = operation->next;				}			}			else {				while(operation) {					IUDateString(operation->date, shortDate, text);					width = StringWidth(text);					if(width > columnList[i].printWidth)					columnList[i].printWidth = width;					operation = operation->next;				}			}			break;						case kOperationColumn_Description:			while(operation) {				width = StringWidth(operation->description);				if(width > columnList[i].printWidth)				columnList[i].printWidth = width;				operation = operation->next;			}			break;						case kOperationColumn_Note:			while(operation) {				width = StringWidth(operation->note);				if(width > columnList[i].printWidth)				columnList[i].printWidth = width;				operation = operation->next;			}			break;						case kOperationColumn_Category:			while(operation) {				if(operation->categoryNum != kUndefinedNum) {					width = StringWidth(categoryList[operation->categoryNum].name);					if(width > columnList[i].printWidth)					columnList[i].printWidth = width;				}				operation = operation->next;			}			break;						case kOperationColumn_PaymentType:			while(operation) {				if(operation->paymentTypeNum != kUndefinedNum) {					width = StringWidth(paymentList[operation->paymentTypeNum].name);					if(width > columnList[i].printWidth)					columnList[i].printWidth = width;				}				operation = operation->next;			}			break;						case kOperationColumn_Custom:			while(operation) {				if(operation->customData[0]) {					width = StringWidth(operation->customData);					if(width > columnList[i].printWidth)					columnList[i].printWidth = width;				}				operation = operation->next;			}			break;						case kOperationColumn_Amount:			while(operation) {				if(appPrefs->flags & kPreferencesFlag_DisplayCurrencySymbol)				AmountToCurrencyString(operation->absoluteAmount, text, operation->owner->data->currencySymbol, !(operation->owner->data->flags & kAccountFlag_NoCents), operation->owner->data->flags & kAccountFlag_SymbolLeads);				else				AmountToString(operation->absoluteAmount, text, 0, 0, !(operation->owner->data->flags & kAccountFlag_NoCents));				width = StringWidth(text);				if(width > columnList[i].printWidth)				columnList[i].printWidth = width;				operation = operation->next;			}			break;						case kOperationColumn_Balance:			while(operation) {				if(appPrefs->flags & kPreferencesFlag_DisplayCurrencySymbol)				AmountToCurrencyString(operation->balance, text, operation->owner->data->currencySymbol, !(operation->owner->data->flags & kAccountFlag_NoCents), operation->owner->data->flags & kAccountFlag_SymbolLeads);				else				AmountToString(operation->balance, text, 0, 0, !(operation->owner->data->flags & kAccountFlag_NoCents));				width = StringWidth(text);				if(width > columnList[i].printWidth)				columnList[i].printWidth = width;				operation = operation->next;			}			break;						case kOperationColumn_Income:			while(operation) {				if(!(operation->flags & kOperationFlag_Expense)) {					if(appPrefs->flags & kPreferencesFlag_DisplayCurrencySymbol)					AmountToCurrencyString(operation->amount, text, operation->owner->data->currencySymbol, !(operation->owner->data->flags & kAccountFlag_NoCents), operation->owner->data->flags & kAccountFlag_SymbolLeads);					else					AmountToString(operation->amount, text, 0, 0, !(operation->owner->data->flags & kAccountFlag_NoCents));					width = StringWidth(text);					if(width > columnList[i].printWidth)					columnList[i].printWidth = width;				}				operation = operation->next;			}			break;						case kOperationColumn_Expense:			while(operation) {				if(operation->flags & kOperationFlag_Expense) {					if(appPrefs->flags & kPreferencesFlag_DisplayCurrencySymbol)					AmountToCurrencyString(operation->amount, text, operation->owner->data->currencySymbol, !(operation->owner->data->flags & kAccountFlag_NoCents), operation->owner->data->flags & kAccountFlag_SymbolLeads);					else					AmountToString(operation->amount, text, 0, 0, !(operation->owner->data->flags & kAccountFlag_NoCents));					width = StringWidth(text);					if(width > columnList[i].printWidth)					columnList[i].printWidth = width;				}				operation = operation->next;			}			break;						case kOperationColumn_Account:			while(operation) {				width = StringWidth(operation->owner->data->name);				if(width > columnList[i].printWidth)				columnList[i].printWidth = width;				operation = operation->next;			}			break;					}		columnList[i].printWidth += 2 * kPrint_LineTextOffset;	}		//Check for min width respect	for(i = 0; i < kOperationNumColumns; ++i) {		XGetIndString(text, kColumnStringsID, columnList[i].id);		minWidth = StringWidth(text) + 2 * kPrint_LineTextOffset;		if(columnList[i].printWidth < minWidth)		columnList[i].printWidth = minWidth;	}		//Count extra pixels	totalWidth = 0;	width = 0;	for(i = 0; i < kOperationNumColumns; ++i)	if(columnList[i].flags & kColumnFlag_Printed) {		totalWidth += columnList[i].printWidth;		if(columnList[i].flags & kColumnFlag_Adjustable)		width += columnList[i].printWidth;	}		//Make sure everything fits on the page	if(totalWidth > pageWidth) {		if(!application->errorManager->Warning(22))		return false;	}		//Set adjustable column width	for(i = 0; i < kOperationNumColumns; ++i)	if((columnList[i].flags & kColumnFlag_Printed) && (columnList[i].flags & kColumnFlag_Adjustable)) {		columnList[i].printWidth += (long) (pageWidth - totalWidth) * (long) columnList[i].printWidth / (long) width;				XGetIndString(text, kColumnStringsID, columnList[i].id);		minWidth = StringWidth(text) + 2 * kPrint_LineTextOffset;		if(columnList[i].printWidth < minWidth)		columnList[i].printWidth = minWidth;	}		//Restore port	SetPort(savePort);		return true;}#if TARGET_API_MAC_CARBONOSErr PrintServer::PrintOperationList(OperationPtr list){	PMPrintSettings		printInfo = NULL;	OSErr				theError;	Boolean				accepted;	PMRect				pmRect;	Rect				pageRect;	long				firstPage,						lastPage,						pageCount;	Boolean				success;	PMPrintSession		printSession;	PMResolution		pmRes;		//Make sure printing is enabled	if(!active)	return paramErr;		//Check operation list	if(list == NULL)	return paramErr;		//Init	theError = PMCreateSession(&printSession);	if(theError)	return theError;		//Ask user	theError = PMCreatePrintSettings(&printInfo);	if(theError)	goto End;	theError = PMSessionDefaultPrintSettings(printSession, printInfo);	if(theError)	goto End;	theError = PMSetPageRange(printInfo, 1, kPMPrintAllPages);	if(theError)	goto End;#if __DEMO__ || __DEBUG__	theError = PMSessionPrintDialog(printSession, printInfo, _pmPageFormat, &accepted);#else	if(SNValid(appPrefs->serialNumber, kSNMagic))	theError = PMSessionPrintDialog(printSession, printInfo, _pmPageFormat, &accepted);	else	theError = noErr;#endif	if(theError)	goto End;	if(!accepted) {		theError = userCanceledErr;		goto End;	}		//Get info	theError = PMGetFirstPage(printInfo, (unsigned long*) &firstPage);	if(theError)	goto End;	theError = PMGetLastPage(printInfo, (unsigned long*) &lastPage);	if(theError)	goto End;		//Build page rect	theError = PMGetAdjustedPageRect(_pmPageFormat, &pmRect);	if(theError)	goto End;	theError = PMGetResolution(_pmPageFormat, &pmRes);	if(theError)	goto End;	if(UseMetricSystem()) {		pageRect.left = pmRect.left + pmRes.hRes * MesureToFloat(appPrefs->marginLeft) / kCmPerInch;		pageRect.right = pmRect.right - pmRes.hRes * MesureToFloat(appPrefs->marginRight) / kCmPerInch;		pageRect.top = pmRect.top + pmRes.vRes * MesureToFloat(appPrefs->marginTop) / kCmPerInch;		pageRect.bottom = pmRect.bottom - pmRes.vRes * MesureToFloat(appPrefs->marginBottom) / kCmPerInch;	}	else {		pageRect.left = pmRect.left + pmRes.hRes * MesureToFloat(appPrefs->marginLeft);		pageRect.right = pmRect.right - pmRes.hRes * MesureToFloat(appPrefs->marginRight);		pageRect.top = pmRect.top + pmRes.vRes * MesureToFloat(appPrefs->marginTop);		pageRect.bottom = pmRect.bottom - pmRes.vRes * MesureToFloat(appPrefs->marginBottom);	}		//Validate column settings	if(!_ValidateColumnSettings(pageRect.right - pageRect.left, list))	goto End;		//Count pages	pageCount = _CountPages(&pageRect, list);		//Print documents	if(pageCount) {		//Create document		theError = PMSessionBeginDocument(printSession, printInfo, _pmPageFormat);		if(theError)		goto End;				while((firstPage <= lastPage) && (firstPage <= pageCount)) {			//Open page			theError = PMSessionBeginPage(printSession, _pmPageFormat, nil);			if(theError)			goto End;						//Print page			success = _DrawPage(firstPage, pageCount, &pageRect, list);						//Close page			theError = PMSessionEndPage(printSession);			if(theError)			goto End;						//Check success			if(!success)			break;						//Update page number			++firstPage;		}				//Close document		PMSessionEndDocument(printSession);	}	End:	//Clean up	if(printInfo)	PMRelease(&printInfo);	PMRelease(&printSession);		return theError;}OSErr PrintServer::PageSetup(){	OSErr				theError;	Boolean				accepted;	PMPrintSession		printSession;		//Make sure printing is enabled	if(!active)	return paramErr;		theError = PMCreateSession(&printSession);	if(theError)	return theError;	theError = PMSessionPageSetupDialog(printSession, _pmPageFormat, &accepted);	if(theError)	goto End;	if(accepted) {		if(printSettings)		DisposeHandle(printSettings);		printSettings = NULL;		theError = PMFlattenPageFormat(_pmPageFormat, &printSettings);		if(theError)		goto End;	}	else	theError = userCanceledErr;End:	PMRelease(&printSession);		return theError;}#elseOSErr PrintServer::PrintOperationList(OperationPtr list){	THPrint				theTHPrint = (THPrint) printSettings;	TPPrPort			printPort;	TPrStatus			status;	Rect				pageRect;	long				firstPage,						lastPage,						pageCount,						i;	Boolean				success;	GWorldPtr			oldGWorld;	GDHandle			oldGDHandle;		//Make sure printing is enabled	if(!active)	return paramErr;		//Check operation list	if(list == NULL)	return paramErr;		//Save GWorld	GetGWorld(&oldGWorld, &oldGDHandle);		//Init	PrOpen();	if(PrError())	return PrError();		//Ask user#if __DEMO__ || __DEBUG__	if(!PrJobDialog(theTHPrint)) {		PrClose();		return PrError();	}#else	if(SNValid(appPrefs->serialNumber, kSNMagic) && !PrJobDialog(theTHPrint)) {		PrClose();		return PrError();	}#endif		//Reset info	firstPage = (**theTHPrint).prJob.iFstPage;	lastPage = (**theTHPrint).prJob.iLstPage;	(**theTHPrint).prJob.iFstPage = 1;	(**theTHPrint).prJob.iLstPage = 9999;		//Build page rect	pageRect = (**theTHPrint).prInfo.rPage;	if(UseMetricSystem()) {		pageRect.left += (float) (**theTHPrint).prInfo.iHRes * MesureToFloat(appPrefs->marginLeft) / kCmPerInch;		pageRect.right -= (float) (**theTHPrint).prInfo.iHRes * MesureToFloat(appPrefs->marginRight) / kCmPerInch;		pageRect.top += (float) (**theTHPrint).prInfo.iVRes * MesureToFloat(appPrefs->marginTop) / kCmPerInch;		pageRect.bottom -= (float) (**theTHPrint).prInfo.iVRes * MesureToFloat(appPrefs->marginBottom) / kCmPerInch;	}	else {		pageRect.left += (float) (**theTHPrint).prInfo.iHRes * MesureToFloat(appPrefs->marginLeft);		pageRect.right -= (float) (**theTHPrint).prInfo.iHRes * MesureToFloat(appPrefs->marginRight);		pageRect.top += (float) (**theTHPrint).prInfo.iVRes * MesureToFloat(appPrefs->marginTop);		pageRect.bottom -= (float) (**theTHPrint).prInfo.iVRes * MesureToFloat(appPrefs->marginBottom);	}		//Validate column settings	if(!_ValidateColumnSettings(pageRect.right - pageRect.left, list))	goto Fail;		//Count pages	pageCount = _CountPages(&pageRect, list);		//Print documents	if(pageCount)	for(i = 0; i < (**theTHPrint).prJob.iCopies; ++i) {		//Create document		printPort = PrOpenDoc(theTHPrint, NULL, NULL);		if(PrError())		goto Fail;		SetPort((GrafPtr) printPort);				while((firstPage <= lastPage) && (firstPage <= pageCount)) {			//Open page			PrOpenPage(printPort, NULL);			if(PrError()) {				PrCloseDoc(printPort);				goto Fail;			}						//Print page			success = _DrawPage(firstPage, pageCount, &pageRect, list);						//Close page			PrClosePage(printPort);			if(PrError()) {				PrCloseDoc(printPort);				goto Fail;			}						//Check success			if(!success)			break;						//Update page number			++firstPage;		}				//Close document		PrCloseDoc(printPort);		if(PrError())		goto Fail;				//Spool		if((**theTHPrint).prJob.bJDocLoop == bSpoolLoop ) {			PrPicFile(theTHPrint, NULL, NULL, NULL, &status);			if(PrError())			goto Fail;		}	}Fail:	//Clean up	PrClose();	SetGWorld(oldGWorld, oldGDHandle);		return PrError();}OSErr PrintServer::PageSetup(){	OSErr				theError;		//Make sure printing is enabled	if(!active)	return paramErr;		PrOpen();	theError = PrError();	if(theError)	return theError;	if(PrStlDialog((THPrint) printSettings))	theError = noErr;	else	theError = userCanceledErr;	PrClose();		return noErr;}#endif